# Text Encryptor: 一款基于自定义字典的文本加密工具

![图片](/Text-Encryptor.png)

## ⚡快速体验

- **[点我前往](https://hjm.krkr.xyz)**

📄 项目简介
---
`Text Encryptor` 是一个纯前端实现的文本加密小工具。它允许用户通过一个完全自定义的“字典”（由单个字或多个字的词组成），将任意文本转换为一种独特的、看起来难以理解的“密文”。

这个工具诞生于一个充满趣味的想法，旨在提供一种非传统、可自定义的文本混淆方式。它非常适合用于创意性的文本转换、社交媒体上的趣味互动，或者仅仅是满足一下将普通文字变得“神秘”的好奇心。

由于其纯前端的特性，所有加密和解密操作都在您的浏览器中本地完成，不会将您的任何数据发送到服务器，从而确保了隐私和安全。

✨ 主要功能
---
- **高度自定义**：使用您能想到的任何字符或词语（用`|`分隔）作为加密字典。
- **两种加密模式**：
  - **静态模式**：相同的原文和字典总是产生相同的密文。
  - **动态加盐模式**：每次加密都会产生不同的密文，安全性更高。
- **自定义密语头**：在动态模式下，可以设置一个专属的“接头暗号”（密语头），只有知道此暗号的人才能解密。
- **即时反馈**：实时在页面上进行加密与解密操作。
- **一键复制**：轻松复制加密或解密后的结果。
- **主题切换**：支持浅色与深色模式，适应不同环境。
- **纯净安全**：完全在浏览器端运行，无需后端服务，不上传任何用户数据。


🚀 使用指南
---

### 1. 设置加密字典
在顶部的输入框中，输入您想用来加密的字符或词语，并使用英文竖线 `|` 分隔。

::: tip 提示
如果您未手动进行分隔，工具会将您输入的内容逐个进行自动分割。
:::

- **推荐用法 (可解密)**: 使用单个汉字、字母或符号。例如：`灵|感|菇|咕|嘎|噜|刮`
- **趣味用法 (不可逆)**: 使用多个汉字组成的词。例如：`你好|世界|今天|天气|不错`

::: warning 重要声明：关于“多字为词”的加密
当您使用包含多个字符的“词”(如 你好|世界)作为字典时，加密功能依然可以工作，但生成的密文可能将无法被正确解密。

根本原因在于匹配的歧义性。解密算法在读取密文时，需要准确地将其分割回加密前的词块。当字典中存在“公共前缀”时，这一过程就会失败。

例如，假设您的字典是 `你好世界|你好啊|你好|你`：

当密文中出现 `你好世界` 时，解码器无法确定是应该将其匹配为 `你`、`你好` 还是 `你好世界`。这种“贪婪匹配”的策略不明确，会导致错误的分割和解码失败。
这种模棱两可的情况使得准确还原原文变得不可能。
虽然使用完全没有相同前缀的多字词（例如 `苹果|香蕉`）在理论上可以避免此问题，但目前工具的解码器是为处理 `单个字符` 而优化的，并未对多字词的复杂情况进行适配。

因此，为了确保加密和解密功能的双向可用性，请务必使用单个、不重复的字符作为字典元素。多字词加密目前仅为一个有趣的、不可逆的单向转换功能。
:::

### 2. 选择加密模式
通过点击 **`当前模式：...`** 按钮在两种模式间切换。

- **静态模式**:
  - **特点**: 对于相同的原文和字典，加密结果永远是固定的。
  - **优点**: 简单、直接。
  - **缺点**: 如果多次发送消息，可能会被通过频率分析猜出规律。

- **动态加盐 (Salted) 模式**:
  - **特点**: 即使原文和字典完全相同，每次加密生成的结果都不同。
  - **工作方式**: 加密时，程序会自动在密文前加入一段随机的“盐”（Salt），解密时再根据这段“盐”来正确还原原始内容。
  - **优点**: 安全性更高，无法通过比较两次密文来寻找规律。
  - **自定义密语头**: 切换到动态模式后，会出现一个输入框，您可以在此设置一个自定义的“密语头”（Custom Salt）。它将替代随机生成的“盐”。这相当于设置了一个密钥，只有知道这个密语头的用户才能解密，进一步增强了保密性。

### 3. 执行加解密
1.  在上方文本框 (`textarea`) 中输入您要处理的文本。
2.  点击 `加密` 或 `解密` 按钮。
3.  结果会立即显示在下方的只读文本框中。
4.  点击 `复制结果` 按钮，轻松分享您的杰作。

🛠️ 技术细节
---
本工具的加密核心思想是一种自定义的 **进制转换算法**。它将文本中每个字符的 Unicode 编码视为一个十进制数，然后将其转换为一个以您的自定义字典为“基数”的特殊“进制”数。

### 字典与环境初始化
1.  **用户字典 (`custom-dict`)**: 用户输入的字符串，通过 `|` 分割成词组数` (FULL_CHAR_ARRAY)`。程序会进行去重，并要求去重后至少有3个词/字。
2.  **分隔符 (`SEPARATOR`)**: 为了在加密后的数据中分隔不同的字符块，程序会从您的字典中确定性地选择一个成员作为分隔符。选择算法是固定的：将字典所有成员的Unicode码位相加，然后对字典长度取模，得到的索引所对应的成员即为分隔符。这确保了只要字典不变，分隔符就不变。
3.  **编码字符集 (`ENCODING_CHARS`)**: 从完整字典中移除分隔符后，剩下的成员构成了用于进制转换的“数字”集合。这个集合的长度就是进制转换的基数 (Base)。

### 核心转换算法
加密和解密依赖于两个核心函数：`toBase` 和 `fromBase`。

```javascript
// 伪代码示例
function toBase(number, charset) {
  // 将一个十进制数(number)转换成一个以charset为基础的新进制数
  // 例如：toBase(65, ['a','b','c']) -> 'bba' (假设)
}

function fromBase(string, charset) {
  // 将一个新进制数(string)转换回原始的十进制数
  // 例如：fromBase('bba', ['a','b','c']) -> 65 (假设)
}
```
- **加密过程**: `原文 -> 字符 -> 字符的Unicode码(十进制) -> toBase转换 -> 新进制表示的字符串`。最后，用 `SEPARATOR` 连接每个字符加密后的结果。
- **解密过程**: `密文 -> split(SEPARATOR) -> 块 -> fromBase转换 -> Unicode码(十进制) -> 原始字符`。

### 模式详解

::: details 静态模式 (Simple Mode)
在静态模式下，加密流程非常直接：
1.  获取原文 `text`。
2.  将 `text` 逐字拆分。
3.  对每个字符 `char`：
    a. 获取其 Unicode 码 `n = char.charCodeAt(0)`。
    b. 使用 `toBase(n, ENCODING_CHARS)` 将其转换为新进制字符串。
4.  使用 `SEPARATOR` 将所有转换后的字符串连接起来。
```javascript
// 静态加密函数核心
function encryptSimple(text) {
  return text.split('')
    .map(char => toBase(char.charCodeAt(0), ENCODING_CHARS))
    .join(SEPARATOR);
}
```
由于 `ENCODING_CHARS` 对于一个固定字典是不变的，所以加密结果也是固定的。
:::

::: details 动态加盐模式 (Salted Mode)
动态模式引入了“盐”（Salt）和“种子伪随机数”来增加不确定性。

**1. 盐 (Salt) 的生成与使用**
- **随机盐**: 如果用户未提供自定义密语头，程序会从 `FULL_CHAR_ARRAY` 中随机挑选2个成员拼接成一个随机盐 `salt`。
- **自定义盐**: 如果用户提供了密语头，则该密语头就是 `salt`。

**2. 种子 (Seed) 的计算**
使用 `salt` 来生成一个数字“种子” `seed`，这个过程是确定性的。
```javascript
const seed = salt.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
```

**3. 字典乱序 (Shuffling)**
`seed` 被用于一个伪随机数生成器，该生成器进而驱动一个 **Fisher-Yates 洗牌算法** (`seededShuffle`)，将 `ENCODING_CHARS` 的顺序打乱，生成一个临时的、本次加密专用的乱序字典 `tempEncodingChars`。

**4. 加密与输出**
- 使用这个**乱序后**的 `tempEncodingChars` 作为 `toBase` 函数的字符集进行加密。
- 最终输出的格式为： `盐 + 分隔符 + 加密数据`。

**解密时**，程序首先从密文的开头提取出“盐”，用它生成完全相同的“种子”，从而得到完全相同的“乱序字典”，最终正确地解密数据。这个机制确保了即使两次加密的原文相同，由于“盐”不同，最终的密文也几乎不可能相同。
:::